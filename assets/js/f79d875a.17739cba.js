"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[6244],{8401:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(5893),s=n(1151);const i={sidebar_position:7},r="Full ELTOO Sequence",o={id:"buildonminima/txntutorial/layer2/eltoofullsequence",title:"Full ELTOO Sequence",description:"We now have all the pieces required to attempt a complete ELTOO transaction sequence. What we can do is create a payment channel between 2 users and update that with bi-directional payments, in a way that does not allow either User to change the expected outcome.",source:"@site/docs/buildonminima/txntutorial/layer2/eltoofullsequence.md",sourceDirName:"buildonminima/txntutorial/layer2",slug:"/buildonminima/txntutorial/layer2/eltoofullsequence",permalink:"/docs/buildonminima/txntutorial/layer2/eltoofullsequence",draft:!1,unlisted:!1,editUrl:"https://github.com/minima-global/minidocs/docs/buildonminima/txntutorial/layer2/eltoofullsequence.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"ELTOO Floating Coin",permalink:"/docs/buildonminima/txntutorial/layer2/eltoofloating"},next:{title:"State Chains",permalink:"/docs/buildonminima/txntutorial/layer2/statechains"}},l={},c=[];function h(e){const t={code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"full-eltoo-sequence",children:"Full ELTOO Sequence"}),"\n",(0,a.jsx)(t.p,{children:"We now have all the pieces required to attempt a complete ELTOO transaction sequence. What we can do is create a payment channel between 2 users and update that with bi-directional payments, in a way that does not allow either User to change the expected outcome."}),"\n",(0,a.jsx)(t.p,{children:"This is the ELTOO contract required by Minima"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"LET st=STATE(99)\r\nLET ps=PREVSTATE(99)\r\n\r\nIF st EQ ps AND @COINAGE GT 256 AND MULTISIG(2 0xUser1Settle 0xUser2Settle) THEN\r\n    RETURN TRUE\r\nELSEIF st GT ps AND MULTISIG(2 0xUser1Update 0xUser2Update) THEN\r\n    RETURN TRUE \r\nENDIF\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The Public keys used by the users are ",(0,a.jsx)(t.code,{children:"0xUser1Settle"})," and ",(0,a.jsx)(t.code,{children:"0xUser2Settle"}),", and ",(0,a.jsx)(t.code,{children:"0xUser1Update"})," and ",(0,a.jsx)(t.code,{children:"0xUser2Update"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"The sequence number is stored in state variable 99."}),"\n",(0,a.jsx)(t.p,{children:"You will note the settlement clause can only be attached to a single output with the exact state sequence number. The update clause can be used as long as it has a higher sequence number - and both use floating coins."}),"\n",(0,a.jsx)(t.p,{children:"How this works (pls read the ELTOO whitepaper to follow more closely):"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"User1 and User2 wish to open a payment channel with 10 Minima each."}),"\n",(0,a.jsx)(t.li,{children:"They start by creating a setup transaction that sends funds to a simple 2of2 multisig worth 20 Minima - the Funding transaction - but do not sign and publish it."}),"\n",(0,a.jsxs)(t.li,{children:["They create a ",(0,a.jsx)(t.strong,{children:"trigger"})," transaction that spends the Funding transaction and sends the funds to the ELTOO contract, with state variable 99 equal to 0. This will effectively start the final settlement sequence - since the @COINAGE timeout is now on chain"]}),"\n",(0,a.jsxs)(t.li,{children:["They create the first ",(0,a.jsx)(t.strong,{children:"settlement"})," transaction that spends the trigger transaction, with state variable 99 set to 0, and sends 10 Minima back to each user."]}),"\n",(0,a.jsx)(t.li,{children:"They sign and share the trigger and initial settlement transaction, and do the same with the funding transaction, and finally publish the Funding transaction."}),"\n",(0,a.jsx)(t.li,{children:"Now - they both have a valid transaction spending the Funding transaction to create the trigger transaction, and both have an initial settlement transaction spending THAT to give them the money back. Phew.. stay with me."}),"\n",(0,a.jsx)(t.li,{children:"Currently ONLY the Funding transaction has been published."}),"\n",(0,a.jsx)(t.li,{children:"Both users can create new update transactions, and their corresponding settlement transactions, that allocate different amounts of the 20 Minima to each user."}),"\n",(0,a.jsx)(t.li,{children:"An Update transaction simply spends their ELTOO coin, and sends the funds back to the same ELTOO coin but with a higher sequence number - in this case state 99."}),"\n",(0,a.jsx)(t.li,{children:"Every Update transaction has a settlement transaction that spends it. And can append ONLY it."}),"\n",(0,a.jsx)(t.li,{children:"So if User1 wants to pay User2 1 Minima - they create a new update transaction with an incremental sequence number, that spends the current ELTOO output and pays to the same ELTOO output, and a new settlement transaction paying 9 Minima to User1 and 11 Minima to User2, with the exact current sequence number as a state variable. They create the settlement FIRST - then the update (so the update can't be posted without a valid settlement)."}),"\n",(0,a.jsx)(t.li,{children:"This continues indefinitely for as long and as fast as the Users want ( there could be more than 2 users of course )"}),"\n",(0,a.jsx)(t.li,{children:"When they want to close the channel - they publish the trigger transaction, then the latest update transaction, and then the latest settlement transaction."}),"\n",(0,a.jsx)(t.li,{children:"IF one of the users publishes an earlier Update transaction, by mistake or maliciously, no problem.. the other user can publish their latest Update transaction on top of that one, because of the @COINAGE timeout - and because they all use floating coins!"}),"\n",(0,a.jsx)(t.li,{children:"And finally - as a nice optimisation - since all parties have a valid trigger, update and settlement transaction, there is no need to actually publish them all on chain - is there ? The final outcome is the outputs of the final settlement transactions, so the parties can negotiate a new transaction, that spends the original funding transaction, instead of the trigger transaction, and pays everyone what they are owed.."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"So in conclusion - the whole process only requires 1 transaction to start the channel, and 1 to close it. But - and this is important - you can run a sequence.. and NOT close at the end. Just use it again when you need to."}),"\n",(0,a.jsx)(t.p,{children:"'Re-balancing' channels allows for the amounts currently owed to each user to be changed so that the channel need not be closed."}),"\n",(0,a.jsx)(t.p,{children:"So if Alice and Bob have a channel, but currently ALL the funds are being sent to Bob, how can Alice continue to use it, and continue to send Bob funds?"}),"\n",(0,a.jsx)(t.p,{children:"Alice and Bob both have channels with Claire.. Alice pays Claire, Claire pays Bob, and Bob pays ( rebalances ) Alice. At the end of this trick everyone still has the same total amount of funds, but the channels have been re-balanced. You would use HTLC contracts to perform this.. Which work just as well off chain as on."}),"\n",(0,a.jsx)(t.p,{children:"Running this from the command line can be quite.. extensive.. But if we simplify this a bit.. and change it to a single signature.. We can play with the transaction script in different scenarios.."}),"\n",(0,a.jsx)(t.p,{children:"So in this simplified - just to play - version.."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"0xFF"})," is the settlement key ",(0,a.jsx)("br",{}),"\r\n",(0,a.jsx)(t.code,{children:"0xEE"})," is the update key"]}),"\n",(0,a.jsx)(t.p,{children:"The script we use is:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"LET st=STATE(99)\r\nLET ps=PREVSTATE(99)\r\n\r\nIF st EQ ps AND @COINAGE GT 20 AND SIGNEDBY(0xFF) THEN\r\n    RETURN TRUE\r\nELSEIF st GT ps AND SIGNEDBY(0xEE) THEN\r\n    RETURN TRUE \r\nENDIF\n"})}),"\n",(0,a.jsx)(t.p,{children:"So - we are assuming the users sign correctly.."}),"\n",(0,a.jsx)(t.p,{children:"We can now run.."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'runscript script:"LET st=STATE(99) LET ps=PREVSTATE(99) IF st EQ ps AND @COINAGE GT 20 AND SIGNEDBY(0xFF) THEN RETURN TRUE ELSEIF st GT ps AND SIGNEDBY(0xEE) THEN RETURN TRUE ENDIF" globals:{"@COINAGE":"23"} state:{"99":"0"} prevstate:{"99":"0"} signatures:["0xFF"]\n'})}),"\n",(0,a.jsx)(t.p,{children:"..and at least play with various scenarios. This variant returns TRUE."})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>r});var a=n(7294);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);