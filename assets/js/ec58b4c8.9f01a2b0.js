"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[5954],{1355:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(5893),a=t(1151);const o={sidebar_position:3},s="Bi-Directional Channel",r={id:"buildonminima/txntutorial/layer2/bidirectionalpayment",title:"Bi-Directional Channel",description:"We want to start up a two way payment channel with someone. So I can send them Minima and they can send coins back to me.",source:"@site/docs/buildonminima/txntutorial/layer2/bidirectionalpayment.md",sourceDirName:"buildonminima/txntutorial/layer2",slug:"/buildonminima/txntutorial/layer2/bidirectionalpayment",permalink:"/docs/buildonminima/txntutorial/layer2/bidirectionalpayment",draft:!1,unlisted:!1,editUrl:"https://github.com/minima-global/minidocs/docs/buildonminima/txntutorial/layer2/bidirectionalpayment.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Uni-Directional Channel",permalink:"/docs/buildonminima/txntutorial/layer2/unidirectionalpayment"},next:{title:"ELTOO Channel",permalink:"/docs/buildonminima/txntutorial/layer2/eltoo"}},h={},c=[];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"bi-directional-channel",children:"Bi-Directional Channel"}),"\n",(0,i.jsx)(n.p,{children:"We want to start up a two way payment channel with someone. So I can send them Minima and they can send coins back to me."}),"\n",(0,i.jsx)(n.p,{children:"If we use the technique we have just demonstrated then what would happen?"}),"\n",(0,i.jsx)(n.p,{children:"Two (or more) people set up a MultiSig where they send 10 Minima each to the contract. They create a new transaction every time there is an update."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"User1 sends User2 - 3 Minima. They create a new fully signed transaction that pays User1 - 7 Minima and User2 - 13 Minima."}),"\n",(0,i.jsx)(n.li,{children:"User2 sends User1 - 1 Minima. They create a new fully signed transaction that pays User1 - 8 Minima and User2 - 12 Minima."}),"\n",(0,i.jsx)(n.li,{children:"And so on.."}),"\n",(0,i.jsx)(n.li,{children:"When they are finished they post the latest transaction and both collect their funds."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Again - although this seems like it is working.. It is not."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The timelock part of the contract is more complicated. If one side does nothing for 30 days, how do both parties recover their initial 10 Minima funds? It is not as simple as one person spending the funds, trusting that person, what forces them to send back the correct amount to both parties?"}),"\n",(0,i.jsx)(n.li,{children:"As before what stops someone posting an earlier transaction - one where they were receiving more funds than they are by the end ? Both parties now have a valid signed transaction whereas before only one party had the complete transaction."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"1 - Can be fixed by creating a valid fully signed transaction spending the MultiSig coin BEFORE it is even posted on chain."}),"\n",(0,i.jsx)(n.p,{children:"So as before the 2 players create the MultiSig contract. Then they use a 10 Minima coin each and send 20 Minma to this script in a single transaction. But they do not sign it and they do not post it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"RETURN MULTISIG(2 0xMyKey 0xTheirKey)\n"})}),"\n",(0,i.jsx)(n.p,{children:"There is no timelock on this contract. Both parties must sign for the coin to be spent."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Now - some Minima low level info. All transactions reference the coins they use as inputs by their CoinID. This is a globally unique 32 byte value that each coin has. You can construct the coinid for an output coin by hashing the Transaction Hash + The Output number of the coin in the transaction. This means you can know the coinid of a coin before it is posted on chain. This means you can construct a transaction that spends a coin that does not exist yet!"})}),"\n",(0,i.jsx)(n.p,{children:"And this is exactly what we do here.. The 2 parties create a transaction that spends the as-yet-unposted coin, and pays 10 Minima back to both, and they both sign that. Now both parties have a valid fully signed transaction that could be used to spend the MultiSig coin, once it is on chain. Then they both sign the initial transaction and post the full 20 Minima on chain to the MultiSig contract. If one of them should disappear and become unresponsive the other has a transaction that sends all the funds back to them. (This trick will be used more later on.. )"}),"\n",(0,i.jsx)(n.p,{children:"2 - Unfortunately the previous pre-made spend transaction still does nothing to prevent either user sending the transaction in the sequence where they have the most. In fact.. It makes matters worse, since if by the end one of the Users has less than 10 Minima he can use the initial transaction to send the original funds back to everyone, and collect their initial 10 Minima."}),"\n",(0,i.jsx)(n.p,{children:"What we need is some way of ordering the transactions so that only the latest transaction is recognised as the valid one. Some way of ensuring that the latest transaction in the sequence will always be the final outcome of the financial relationship.."}),"\n",(0,i.jsx)(n.p,{children:"Enter ELTOO."})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>s});var i=t(7294);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);