"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[1590],{3787:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});var t=r(5893),a=r(1151);const i={sidebar_position:14},o="Coin Flip",s={id:"buildonminima/txntutorial/layer1/coinflip",title:"Coin Flip",description:"And finally, here is a full example of a 'game' that can be played via smart contracts. It is a coin toss.",source:"@site/docs/buildonminima/txntutorial/layer1/coinflip.md",sourceDirName:"buildonminima/txntutorial/layer1",slug:"/buildonminima/txntutorial/layer1/coinflip",permalink:"/docs/buildonminima/txntutorial/layer1/coinflip",draft:!1,unlisted:!1,editUrl:"https://github.com/minima-global/minidocs/docs/buildonminima/txntutorial/layer1/coinflip.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"The Vault",permalink:"/docs/buildonminima/txntutorial/layer1/thevault"},next:{title:"Introduction",permalink:"/docs/buildonminima/txntutorial/layer2/intro"}},l={},h=[];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"coin-flip",children:"Coin Flip"}),"\n",(0,t.jsx)(n.p,{children:"And finally, here is a full example of a 'game' that can be played via smart contracts. It is a coin toss."}),"\n",(0,t.jsx)(n.p,{children:"2 users flip a coin and heads one wins tails the other wins. The randomness is added to the system by both players picking a random number and committing to it via the hash. Thereby forcing them not to change it when either shows the preimage of that hash. So both players pick a random number, those numbers are hashed, and if the first byte of the final hash is less than 128 Player 1 wins else Player 2 wins."}),"\n",(0,t.jsx)(n.p,{children:"This game is very very simple but more complex games with more participants can be written in a similar fashion."}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Importantly - this is running on Layer 1. This is running on chain. So it is slow and expensive. ",(0,t.jsx)("br",{}),"\r\nThis is not where you would play this game. You want to be running it on Layer 2 - which is instant and free. You want to be off chain. You don't want to be on Layer 1 - you want to be on Layer 2, and this is where the true power of the UTXO model (Unspent Transaction Outputs) coupled with the ELTOO framework really shines. ",(0,t.jsx)("br",{}),"\r\nBecause this simple game can be 'lifted' off layer 1 and played out on layer 2. In fact any sequence of transactions between a group of users can be lifted off layer 1 and onto layer 2."]})}),"\n",(0,t.jsx)(n.p,{children:"More on that later. For now - let's see the script:"}),"\n",(0,t.jsx)(n.p,{children:"You would need an application to manage this sequence, and keep track of where you were, checking the chain for responses and firing off the next required transaction in the sequence. Originally, way back when, I had a web app that did just that over RPC with the Minima node."}),"\n",(0,t.jsx)(n.p,{children:"A MiniDAPP called CoinFlip - for those that remember."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"/*\r\nCOIN FLIP SCRIPT\r\nFunky little script.. with comments. \r\n\r\nEach 'Round' is another transaction. \r\n\r\nThe State Variables are:\r\n0 - Round Number\r\n\r\nPLAYER 1 puts his details in state 1-3:\r\n1 - Payout address\r\n2 - Cancel / Last Resort key\r\n3 - Hash of random number\r\n\r\nPLAYER 2 adds his details:\r\n4 - Last Resort key\r\n5 - Hash of random number\r\n\r\nThen player 1 reveals:\r\n6 - Preimage of 3\r\n\r\nThen player 2 reveals and pays out (wins 95% or takes back 5% - incentive to finish game):\r\n7 - Preimage of 5\r\n\r\nIf Player 1 or 2 do not reveal or pay out in a time limit\r\nthe other player gets everything as a last resort.. \r\n*/\r\n\r\n/*-----------SCRIPT------------*/\r\n\r\n/* What state are we at */\r\nLET round = STATE ( 0 )\r\nLET prevround = PREVSTATE ( 0 )\r\n\r\n/* Make sure we are 1 round ahead of before */ \r\nASSERT round EQ INC ( prevround )\r\n\r\n/* PLAYER 2 Joins OR Player 1 Cancels */ \r\nIF round EQ 1 THEN\r\n\r\n    /* Player 1 can still cancel at this stage */\r\n    IF SIGNEDBY ( PREVSTATE ( 2 ) ) THEN RETURN TRUE ENDIF\r\n\r\n    /* Make sure all the details are kept */ \r\n    ASSERT SAMESTATE ( 1 3 )\r\n\r\n    /* This round someone accepts.. check double the money*/\r\n    RETURN VERIFYOUT ( @INPUT @ADDRESS ( @AMOUNT * 2 ) @TOKENID TRUE )\r\n\r\n/* PLAYER 1 REVEALS HIS HAND */ \r\nELSEIF round EQ 2 THEN\r\n\r\n    /* If player 1 does NOT reveal.. in time limit (here 20 mins).. player 2 gets everything */\r\n    IF @COINAGE GT 64 AND SIGNEDBY ( PREVSTATE ( 4 ) ) THEN RETURN TRUE ENDIF\r\n\r\n    /* make sure all the details of both players are kept.. */ \r\n    ASSERT SAMESTATE ( 1 5 )\r\n\r\n    /* Now check that the preimage of player 1 is correct */ \r\n    LET ponehash = STATE ( 3 )\r\n    LET preimage = STATE ( 6 )\r\n    ASSERT SHA3 ( preimage ) EQ ponehash\r\n\r\n    /* OK - He has shown his random number.. continue */\r\n    RETURN VERIFYOUT ( @INPUT @ADDRESS @AMOUNT @TOKENID TRUE )\r\n\r\n/* PLAYER 2 REVEALS AND PAYS OUT */ \r\nELSEIF round EQ 3 THEN\r\n\r\n    /* If player 2 does NOT reveal.. in time limit (here 20 mins).. player 1 gets everything */\r\n    IF @COINAGE GT 64 AND SIGNEDBY ( PREVSTATE ( 2 ) ) THEN RETURN TRUE ENDIF\r\n\r\n    /* make sure all the details of both players are kept.. */ \r\n    ASSERT SAMESTATE ( 1 6 )\r\n\r\n    /* Now check that the preimage of player 2 is correct */ \r\n    LET ptwohash = STATE ( 5 )\r\n    LET ptwopreimage = STATE ( 7 )\r\n    ASSERT SHA3 ( ptwopreimage ) EQ ptwohash\r\n\r\n    /* OK - lets see who wins..! */\r\n    LET ponepreimage = STATE ( 6 )\r\n    LET rand = SHA3 ( CONCAT( ponepreimage ptwopreimage ) )\r\n\r\n    /* GET THE FIRST BYTE*/\r\n    LET val = NUMBER ( SUBSET ( 0 1 rand ) )\r\n    IF ( val LT 128 ) THEN LET winner = 1 ELSE LET winner = 2 ENDIF\r\n\r\n    /* Calculate the Payout for each */\r\n    LET paywinner = @AMOUNT * 0.95 LET payloser = @AMOUNT - paywinner\r\n\r\n    /* Check that State 8 states the correct winner.. for future easy lookup */ \r\n    ASSERT STATE ( 8 ) EQ winner\r\n    ASSERT STATE ( 9 ) EQ paywinner\r\n\r\n    /* Now check the payout! */\r\n    LET poneaddress = STATE ( 1 ) \r\n    IF winner EQ 1 THEN\r\n        ASSERT VERIFYOUT ( @INPUT poneaddress paywinner @TOKENID TRUE ) \r\n    ELSE\r\n        ASSERT VERIFYOUT ( @INPUT poneaddress payloser @TOKENID TRUE ) \r\n    ENDIF\r\n\r\n    /* And finally check the signature - MUST sign as otherwise someone else could claim */ \r\n    RETURN SIGNEDBY ( PREVSTATE ( 4 ) )\r\n\r\nENDIF\n"})}),"\n",(0,t.jsx)(n.p,{children:"That's quite a long script.. You could MAST the sections in each round to reduce the size you needed to post on chain."}),"\n",(0,t.jsx)(n.p,{children:"Essentially the game starts when Player 1 sends some coins to this Contract with the initial 4 state variables defined, 0-3. Then player 2 responds, by spending the coin, adding more state variables, and copying the previous ones so that the memory is intact. And so on.."}),"\n",(0,t.jsxs)(n.p,{children:["You can follow the logic through, with each round incrementing the state(0) value, so the script knows which section to run. The state is verified in the ",(0,t.jsx)(n.code,{children:"ASSERT round EQ INC ( prevround )"})," ensuring that every transaction in the sequence MUST increase the state(0) / round number by one."]}),"\n",(0,t.jsx)(n.p,{children:"Next - we get exciting.. we go Layer 2.. we go ELTOO."})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>s,a:()=>o});var t=r(7294);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);